[["index.html", "Analysis of MOB Visium data using STutility 1 Introduction", " Analysis of MOB Visium data using STutility Authors: Lovisa Franzén, Ludvig Larsson, Mengxiao He 2022-04-26 1 Introduction Hello! Today we will have a closer look at two 10x Genomics Visium Gene Expression data sets generated from mouse olfactory bulb (MOB) tissue. We will go through how a general workflow can look like when processing, analyzing, and visualzing the data. The R package that we will use for this is STutility1, a tool built upon Seurat2, that is specialized at handling spatial transcriptomics (ST) and Visium data. References: 1. Bergenstråhle J, Larsson L, Lundeberg J. Seamless integration of image and molecular analysis for spatial transcriptomics workflows. BMC Genomics. 2020 Jul 14;21(1):482. doi: 10.1186/s12864-020-06832-3. PMID: 32664861; PMCID: PMC7386244. 2. Stuart T, Butler A, Hoffman P, Hafemeister C, Papalexi E, Mauck WM 3rd, Hao Y, Stoeckius M, Smibert P, Satija R. Comprehensive Integration of Single-Cell Data. Cell. 2019 Jun 13;177(7):1888-1902.e21. doi: 10.1016/j.cell.2019.05.031. Epub 2019 Jun 6. PMID: 31178118; PMCID: PMC6687398. . . . . "],["set-up.html", " 2 Set up", " 2 Set up First, we need to install and/or load the necessary packages and import the Visium data. To install STutility, follow the guide provided in the vignette: https://ludvigla.github.io/STUtility_web_site/Installation.html When loading STutility, it automatically imports the packages Seurat and ggplot2. library(STutility) library(DT) Next, we need to prepare the input files and how to import the data into R. 10X Visium data output is produced with the spaceranger command line tool from raw fastq files. The output includes a number of files, and the ones that needs to be imported into R for STutility are the following: filtered_feature_bc_matrix.h5 or raw_feature_bc_matrix.h5 — Gene expression matrices in .h5 format containing the raw UMI counts for each spot and each gene. The “filtered_feature_bc_matrix.h5” matrix contains spots that are localized under the tissue while the “raw_feature_bc_matrix.h5” matrix contain all spots from the entire capture area. NOTE: if you want to include spots outside of the tissue, you need to set disable.subset = TRUE when running InputFromTable. tissue_positions_list.csv — contains capture-spot barcodes and corresponding capture-spot coordinates. tissue_hires_image.png — H&amp;E image in PNG format with a width of 2000 pixels. scalefactors_json.json — This file contains scaling factors subject to the H&amp;E images of different resolutions. E.g. “tissue_hires_scalef”: 0.1, means that the pixel coordinates in the “tissue_positions_list.csv” table should be scaled by a factor of 0.1 to match the size of the “hires_image.png” file. The recommended method to read the files into R is via the creation of a data.frame that we will call the infoTable. There are four columns in this table that are required for Visium data: samples, spotfiles, imgs and json. These columns specify the paths to the required input files. Any number of extra columns can be added to the infoTable data frame that you want to include as meta data in your Seurat object, e.g. “gender”, “age”, “slide_id” etc. "],["assemble-input-files.html", "2.1 Assemble input files", " 2.1 Assemble input files Now let’s create the infoTable and add a bit more information about the samples! With these samples, we know that one MOB is of higher quality than the other, so let’s add that information and we might be able to check later how that influences the data. We’ll also add the slide and capture area identifiers to the meta data - that’s always useful information to keep! infoTable &lt;- data.frame(samples = c(file.path(&quot;../data&quot;, &quot;V19D02-087_B1&quot;, &quot;filtered_feature_bc_matrix.h5&quot;), file.path(&quot;../data&quot;, &quot;V19T26-013_A1&quot;, &quot;filtered_feature_bc_matrix.h5&quot;)), spotfiles = c(file.path(&quot;../data&quot;, &quot;V19D02-087_B1&quot;, &quot;spatial&quot;, &quot;tissue_positions_list.csv&quot;), file.path(&quot;../data&quot;, &quot;V19T26-013_A1&quot;, &quot;spatial&quot;,&quot;tissue_positions_list.csv&quot;)), imgs = c(file.path(&quot;../data&quot;, &quot;V19D02-087_B1&quot;, &quot;spatial&quot;, &quot;tissue_hires_image.png&quot;), file.path(&quot;../data&quot;, &quot;V19T26-013_A1&quot;, &quot;spatial&quot;,&quot;tissue_hires_image.png&quot;)), json = c(file.path(&quot;../data&quot;, &quot;V19D02-087_B1&quot;, &quot;spatial&quot;, &quot;scalefactors_json.json&quot;), file.path(&quot;../data&quot;, &quot;V19T26-013_A1&quot;, &quot;spatial&quot;,&quot;scalefactors_json.json&quot;)), slide_id = c(&quot;V19D02-087_B1&quot;, &quot;V19T26-013_A1&quot;), batch = c(&quot;A&quot;, &quot;B&quot;), quality = c(&quot;high&quot;, &quot;low&quot;), tissue = c(&quot;MOB&quot;, &quot;MOB&quot;) ) datatable(infoTable, rownames = F, caption = paste(&quot;Our infoTable with added sample information&quot;)) "],["import-data.html", "2.2 Import data", " 2.2 Import data It’s time to import the data into R using the function InputFromTable and providing our infoTable to point at where the data is located. In addition, we can perform some initial quality filtering of the data, for instance removing spots and genes with very low UMI counts. se &lt;- InputFromTable(infotable = infoTable, minSpotsPerGene = 5, minUMICountsPerGene = 100, minUMICountsPerSpot = 500, platform = &quot;Visium&quot;, verbose = T) ## Using spotfiles to remove spots outside of tissue ## Loading ../data/V19D02-087_B1/filtered_feature_bc_matrix.h5 count matrix from a &#39;Visium&#39; experiment ## Loading ../data/V19T26-013_A1/filtered_feature_bc_matrix.h5 count matrix from a &#39;Visium&#39; experiment ## ## ------------- Filtering (not including images based filtering) -------------- ## Spots removed: 23 ## Genes removed: 37684 ## Saving capture area ranges to Staffli object ## After filtering the dimensions of the experiment is: [11025 genes, 2346 spots] To check everything looks ok, we can do a few plots of the data. col_samples &lt;- c(&quot;#1954A6&quot;, &quot;#A7C947&quot;) VlnPlot(se, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;), group.by = &quot;slide_id&quot;, cols = col_samples) Figure 2.1: Violin plot of unique genes and UMIs. col_scale &lt;- c(&quot;darkblue&quot;, &quot;cyan&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;darkred&quot;) ST.FeaturePlot(se, features = c(&quot;nFeature_RNA&quot;), cols = col_scale, ncol = 2, pt.size = 1.8, label.by = &quot;slide_id&quot;) Figure 2.2: Spatial distribution of unique genes and UMIs. Seems like the data is in! From these plots you can clearly see that one of the tissues is of lower quality and thus have fewer unique genes (nFeature_RNA) and UMIs (nCount_RNA). We can also easily plot the spatial locations of a few selected genes. The MOB consists of multiple layers, including the glomerular layer, the external plexiform layer, the mitral cell layer, the internal plexiform layer, and the granule cell layer. A few known gene markers for a couple of these layers are Cdhr1 and Camk2a, so let’s plot and see how it looks. col_scale &lt;- viridis::magma(n = 11, direction = -1) p1 &lt;- ST.FeaturePlot(se, features = c(&quot;Cdhr1&quot;, &quot;Camk2a&quot;), indices = 1, max.cutoff = 10, ncol = 1, grid.ncol = 1, cols = col_scale, label.by = &quot;slide_id&quot;, show.sb = FALSE) p2 &lt;- ST.FeaturePlot(se, features = c(&quot;Cdhr1&quot;, &quot;Camk2a&quot;), indices = 2, max.cutoff = 3, ncol = 1, grid.ncol = 1, cols = col_scale, label.by = &quot;slide_id&quot;, show.sb = FALSE) p1 - p2 Figure 2.3: Spatial distribution of marker genes. As one can see, the sample of poorer quality is also more sparse in its gene expression of these marker genes. To address this issue and to be able to analyze these two sections together we need to proceed with the next steps of the analysis. But first of all it can be good to perform some more quality control and filter the data further. "],["he-images.html", " 3 H&amp;E images", " 3 H&amp;E images The H&amp;E image is an integral part of the 10x Visium data set. It provides high resolution detail about tissue morphology and serves as a useful guide to explore and validate findings and can even provide additional information to be integrated with gene expression data. "],["load-images.html", "3.1 Load images", " 3.1 Load images With the Seurat object created, we are ready to load the H&amp;E images from the file paths provided in the infoTable. The LoadImages() function allow you to load the images into the Seurat object and will automatically save a scaled down version of each image that you can use for plotting. se &lt;- LoadImages(se, time.resolve = FALSE, verbose = TRUE) ## Loading images for 2 samples: ## Reading ../data/V19D02-087_B1/spatial/tissue_hires_image.png for sample 1 ... ## Scaling down sample 1 image from 1979x2000 pixels to 400x404 pixels ## Reading ../data/V19T26-013_A1/spatial/tissue_hires_image.png for sample 1 ... ## Scaling down sample 2 image from 2000x2000 pixels to 400x400 pixels ImagePlot(se, method = &quot;raster&quot;, type = &quot;raw&quot;, annotate = FALSE) Figure 3.1: Raw H&amp;E images "],["mask-images.html", "3.2 Mask images", " 3.2 Mask images Next, we can apply a mask to our H&amp;E images to remove the background. Note that the masking procedure relies on sharp contrasts in the H&amp;E image and will therefore perform poorly on images with diffuse borders in which case the masking strategy needs to be adjusted or done manually. se &lt;- MaskImages(object = se) ImagePlot(se, method = &quot;raster&quot;, type = &quot;masked&quot;, annotate = FALSE) Figure 3.2: Masked H&amp;E images "],["process-images.html", "3.3 Process images", " 3.3 Process images As you can see, the two sections are placed in different orientations on the capture area. Let’s take care of that. STUtility provide 3 different methods to adjust the H&amp;E images: * WarpImages : Apply predefined rigid transformations such as rotation, translation and reflection * AlignImages : An automatic image registration method that relies on edge detection. This method is sensitive to deformations and other tissue artefacts. * ManualALignImages : Opens up an interactive shiny web application where rigid transformations such as rotations, translations and reflections can be applied to the data. Below, we’ll flip the first section -90deg and apply a translation along the y axis: #&#39; Lets rotate the first section 90 degrees to match the second section transforms &lt;- list(&quot;1&quot; = list(&quot;angle&quot; = -90, &quot;shift.y&quot; = -60)) se &lt;- WarpImages(se, transforms) ImagePlot(se, method = &quot;raster&quot;, annotate = FALSE) Figure 3.3: Processed H&amp;E images Now that we have the two tissue sections aligned, it will be much easier to compare expression patterns between them. We can now also plot gene expression values on top of the H&amp;E images. col_scale &lt;- c(&quot;darkblue&quot;, &quot;cyan&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;darkred&quot;) FeatureOverlay(se, features = &quot;Nrgn&quot;, sampleids = 1:2, ncols = 2, pt.size = 1.5, max.cutoff = &quot;q99&quot;, cols = col_scale, add.alpha = TRUE, label.by = &quot;slide_id&quot;, type = &quot;processed&quot;) Figure 3.4: Spatial distribution of Nrgn For the marker gene Nrgn, we can see that the gene is specifically expressed in one region of the MOB, although the counts are much higher in the first section due to the overall higher quality of the data set. Before we move on with downstream normalization and filtering, let’s spend a few minutes on quality control and filtering. "],["quality-control-and-filtering.html", " 4 Quality control and filtering", " 4 Quality control and filtering We should always check the quality of our data before proceeding with downstream analysis. For example, does the data reflect our expectations about the tissue? Do we need to remove outliers before downstream analysis? "],["basic-qc-metrics.html", "4.1 Basic QC metrics", " 4.1 Basic QC metrics Plotting the spatial distribution of a certain QC metrics is often very useful. Below we show the distribution of unique genes and number of UMIs per spot in our two MOB tissue sections. By visual inspection we can see that both QC metrics correlate with cell density, which is what we generally expect to see. If this is not the case, we might have a technical issue such as tissue detachment, uneven permeabilization, overpermeabilization, mRNA degradation etc. In this particular example, we see that even though the QC metrics correlate with cell density, there is a strong batch effect between the two sections where the second tissue section has much lower overall quality. col_scale &lt;- c(&quot;darkblue&quot;, &quot;cyan&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;darkred&quot;) FeatureOverlay(se, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;), cols = col_scale, ncols = 2, pt.size = 1.3, label.by = &quot;slide_id&quot;, sampleids = 1:2, value.scale = &quot;all&quot;) Figure 4.1: Spatial QC metrics overlay. nFeature_RNA = unique genes; nCount_RNA = UMI count Visualizing the distribution of selected QC metrics can be useful to better understand the data. For example, if you need to select filtering thresholds. For our example, it becomes clear that our two tissue section data sets are highly different in terms of quality. When analyzing a Visium data set generated from a new tissue type, it can be very difficult to determine whether the QC metrics are reasonable. Here, when comparing the two tissue sections side by side, it becomes clear that the second data set is of low quality. As a rule of thumb, we expect to obtain at least 1,000 unique genes per spot on average but you should know that this is highly tissue dependent. Low quality will have a negative impact on downstream analysis. col_samples &lt;- c(&quot;#1954A6&quot;, &quot;#A7C947&quot;) p1 &lt;- ggplot() + geom_histogram(data = se[[]], aes(nFeature_RNA, fill = slide_id), alpha = 0.6, bins = 50, position = &quot;identity&quot;) + scale_fill_manual(values = col_samples) + ggtitle(&quot;A) Unique genes per spot&quot;) &amp; NoLegend() p2 &lt;- ggplot() + geom_histogram(data = se[[]], aes(nCount_RNA, fill = slide_id), alpha = 0.6, bins = 50, position = &quot;identity&quot;) + scale_fill_manual(values = col_samples) + ggtitle(&quot;B) Total counts per spot&quot;) &amp; NoLegend() gene_attr &lt;- rbind(data.frame(nUMI = Matrix::rowSums(se@assays$RNA@counts[, se$slide_id == &quot;V19D02-087_B1&quot;]), nSpots = Matrix::rowSums(se@assays$RNA@counts[, se$slide_id == &quot;V19D02-087_B1&quot;] &gt; 0), slide_id = &quot;V19D02-087_B1&quot;), data.frame(nUMI = Matrix::rowSums(se@assays$RNA@counts[, se$slide_id == &quot;V19T26-013_A1&quot;]), nSpots = Matrix::rowSums(se@assays$RNA@counts[, se$slide_id == &quot;V19T26-013_A1&quot;] &gt; 0), slide_id = &quot;V19T26-013_A1&quot;)) p3 &lt;- ggplot() + geom_histogram(data = gene_attr, aes(nUMI, fill = slide_id), alpha = 0.6, bins = 50, position = &quot;identity&quot;) + scale_fill_manual(values = col_samples) + scale_x_log10() + ggtitle(&quot;C) Total counts per gene (log10 scale)&quot;) p4 &lt;- ggplot() + geom_histogram(data = gene_attr, aes(nSpots, fill = slide_id), alpha = 0.6, bins = 50, position = &quot;identity&quot;) + scale_fill_manual(values = col_samples) + ggtitle(&quot;D) Total spots per gene&quot;) (p1 - p2)/(p3 - p4) &amp; theme_linedraw() Figure 4.2: Visualization of basic QC metrics. A) Histogram of unique genes per spot. B) Histogram of total UMI counts per spot. C) Total counts per gene in log10-scale. This is useful to inspect if you need to filter out lowly expressed genes from your data set. D) Total spots per gene. Here we can clearly see a substantial gene dropout in the low quality data set. "],["other-metrics.html", "4.2 Other metrics", " 4.2 Other metrics It can also be useful to explore other features of the data set to use for filtering, for example mitochondrial transcript content or ribosomal protein coding transcript content. Mitochondrial genes are prefixed with “mt-” in MGI nomenclature so we can collect these genes and then calculate the percentage of mitochondrial content per spot and add this information to our meta.data. se &lt;- PercentageFeatureSet(se, pattern = &quot;^mt-&quot;, col.name = &quot;pct.mt&quot;) se &lt;- PercentageFeatureSet(se, pattern = &quot;^Rpl|^Rps-&quot;, col.name = &quot;pct.ribo&quot;) col_samples &lt;- c(&quot;#1954A6&quot;, &quot;#A7C947&quot;) p1 &lt;- ST.FeaturePlot(se, features = c(&quot;pct.mt&quot;), cols = col_scale, ncol = 2, pt.size = 1.3, show.sb = FALSE, label.by = &quot;slide_id&quot;) p2 &lt;- VlnPlot(se, features = c(&quot;pct.mt&quot;), group.by = &quot;slide_id&quot;, cols = col_samples) &amp; NoLegend() p3 &lt;- ST.FeaturePlot(se, features = c(&quot;pct.ribo&quot;), cols = col_scale, ncol = 2, pt.size = 1.3, show.sb = FALSE, label.by = &quot;slide_id&quot;) p4 &lt;- VlnPlot(se, features = c(&quot;pct.ribo&quot;), group.by = &quot;slide_id&quot;, cols = col_samples) &amp; NoLegend() (p1-p2) / (p3-p4) &amp; patchwork::plot_layout(widths = c(2,1)) Figure 4.3: Mitochondrial transcript content and ribosomal protein coding transcript content. "],["filter.html", "4.3 Filter", " 4.3 Filter Finally, let’s filter the data to remove spots with very high mitochondrial content. You can filter the data based on many different parameters, it’s up to you to test and decide what you think is best for the analysis you want to perform. # Keep spots with less than 30% mitochondrial content se.subset &lt;- SubsetSTData(se, expression = pct.mt &lt; 30) cat(&quot;Spots removed: &quot;, ncol(se) - ncol(se.subset), &quot;\\n&quot;) ## Spots removed: 169 "],["data-analysis.html", " 5 Data analysis", " 5 Data analysis In this section we’ll have a look at the Seurat workflow for normalization, dimensionality reduction and batch correction. You can find more detailed information and tutorials on the Seurat webpage as well as on our own STUtility web page. "],["normalization.html", "5.1 Normalization", " 5.1 Normalization In order to normalize the data we recommend using variance stabilized transformation available in the SCTransform function in Seurat as of v3.0. Since we have a known batch effect between the two sections, we will try to deal with that by specifying the batch in the vars.to.regress argument of the function. With more severe batch effects, you may need to integrate the two sections using a data integration method. Let’s see the effect of batch correction. se.norm &lt;- SCTransform(se.subset) se.cor &lt;- SCTransform(se.subset, vars.to.regress = &quot;batch&quot;) "],["dimensionality-reduction.html", "5.2 Dimensionality reduction", " 5.2 Dimensionality reduction We’ll start off by running a simple principal component analysis (PCA) followed by UMAP for visualization. We can color the points based on the batch to see how well the two data sets mix. se.norm &lt;- se.norm %&gt;% RunPCA() %&gt;% RunUMAP(dims = 1:30) se.cor &lt;- se.cor %&gt;% RunPCA() %&gt;% RunUMAP(dims = 1:30) p1 &lt;- DimPlot(se.norm, reduction = &quot;umap&quot;, group.by = &quot;batch&quot;, cols = col_samples) + labs(title=&quot;No correction&quot;) p2 &lt;- DimPlot(se.cor, reduction = &quot;umap&quot;, group.by = &quot;batch&quot;, cols = col_samples) + labs(title=&quot;SCT batch correction&quot;) p1 - p2 Figure 5.1: UMAP embedding of MOB data with and without batch correction. Looks like adding the batch correction in SCTransform helped quite a lot to mitigate the batch effect, although we still see that the two tissue sections separate in the UMAP embedding. "],["data-integration.html", "5.3 Data integration", " 5.3 Data integration Sometimes, data integration techniques are necessary to perform a joint analysis of the data. Let’s try one of the most popular methods called Harmony. We’ll run this method on our corrected data to see if we can improve it even further. Good to keep in mind is that Harmony operates on the PC vectors, and not on the gene expression values. library(harmony) se.cor &lt;- RunHarmony(se.cor, group.by.vars = &quot;batch&quot;, assay.use = &quot;SCT&quot;) %&gt;% RunUMAP(reduction = &quot;harmony&quot;, dims = 1:30, reduction.name = &quot;umap.harmony&quot;) p1 &lt;- DimPlot(se.norm, reduction = &quot;umap&quot;, group.by = &quot;batch&quot;, cols = col_samples) + labs(title=&quot;A) No correction&quot;) p2 &lt;- DimPlot(se.cor, reduction = &quot;umap&quot;, group.by = &quot;batch&quot;, cols = col_samples) + labs(title=&quot;B) SCT batch correction&quot;) p3 &lt;- DimPlot(se.cor, reduction = &quot;umap.harmony&quot;, group.by = &quot;batch&quot;, cols = col_samples) + labs(title=&quot;C) SCT batch correction + Harmony&quot;) p1 + p2 + p3 Figure 5.2: UMAP embedding of MOB data. A) No correction. B) Correction by regression. C) Correction by data integration As you can see, we can integrate the data from our two sections pretty well using these approaches. Harmony seems to have helped align the data very well, and now we can use these harmonized vectors to continue with some downstream analyses instead. "],["spatial-color-projection.html", "5.4 Spatial color projection", " 5.4 Spatial color projection It is also possible to project the results of a UMAP onto our tissue sections. This can be a quick and useful way of identifying regions with similar gene expression profiles across multiple tissue sections. We’ll use a neat trick here where we first run UMAP with 3 components, then we mix these three component values to produce an RGB color. This way we obtain a mixed color for each combination of UMAP components for each spot. se.cor &lt;- RunUMAP(object = se.cor, n.components = 3, reduction = &quot;harmony&quot;, dims = 1:30, reduction.name = &quot;umap.3d&quot;) ST.DimPlot(object = se.cor, dims = 1:3, reduction = &quot;umap.3d&quot;, blend = TRUE, dark.theme = TRUE, pt.size = 1.2) Figure 5.3: Spatial color projection of a 3D UMAP "],["non-negative-matrix-factorization.html", "5.5 Non-negative matrix factorization", " 5.5 Non-negative matrix factorization Another fun analysis to run is NMF, which is another dimensionality reduction method that has proven to be great at finding underlying patterns of transcriptomic profiles. Briefly, starting with an expression matrix A with non-negative elements, NMF tries to decompose A into k preselected factors: \\[ A \\approx W*H \\] A factor can be thought of as an expression profile that reflects some unknown signal of heterogeneity such as that of a cell type, multiple co-localized cell types or a biological process. From the resulting matrix H, we can extract information about the contribution of spots to each factor which allows us to visualize the factors on our tissue sections. From the second matrix W, we can extract information about the contribution of genes to each factor. In other words, we can both visualize the factors spatially and characterize them by their top contributing genes. Let’s have a look at an example: se.cor &lt;- RunNMF(se.cor, nfactors = 10) In the plot below, we show five selected factors with their spatial distribution and top contributing genes. FactorPlot &lt;- function(object, factor = 1, col.scale = c(&quot;darkblue&quot;, &quot;cyan&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;darkred&quot;) ) { p1 &lt;- ST.DimPlot(object, dims = factor, label.by = &quot;slide_id&quot;, center.zero = F, reduction = &quot;NMF&quot;, ncol = 2, pt.size = 1, cols = col.scale, show.sb = F) &amp; labs(fill = &quot;factor\\nactivity&quot;) p2 &lt;- FactorGeneLoadingPlot(object, factor = factor, dark.theme = F) + labs(title = paste(&quot;Factor&quot;, factor, &quot;loadings&quot;)) + theme(axis.title.y = element_blank()) &amp; labs(y = &quot;gene weight&quot;) cowplot::plot_grid(p1, p2, ncol = 2, rel_widths = c(2, 1)) } # FactorPlot(object = se.cor, col.scale = col_scale) plot_list &lt;- lapply(1:10, function(i) { FactorPlot(object = se.cor, factor = i, col.scale = col_scale) }) cowplot::plot_grid(plotlist = plot_list[c(1, 2, 3, 5, 9)], ncol = 1) Figure 5.4: Five example factors from an NMF analysis with k = 10. The left hand side shows the activity of the factor on the tissue sections whereas the right hand side shows the top contributing genes with their associated weights Looking at these results, you can see that some factors still display a large difference between the two sections, which is caused by the difference in quality. Even with an effective normalization procedure, some of the factor associated marker genes are still lowly expressed and/or have low detection rates. The NMF method does not operate on the integrated data and is therefore unable to adjust for strong batch effects. However, it is often possible to pick up signals of technical variation with NMF in which case such “technical” factors can be excluded. "],["clustering.html", "5.6 Clustering", " 5.6 Clustering We can use the harmonized PC vectors (integrated) as input for the clustering algorithm. se.cor &lt;- FindNeighbors(object = se.cor, verbose = T, reduction = &quot;harmony&quot;, dims = 1:20) se.cor &lt;- FindClusters(se.cor) col_clusters &lt;- RColorBrewer::brewer.pal(10, name = &quot;Set3&quot;) p1 &lt;- ST.FeaturePlot(se.cor, features = &quot;seurat_clusters&quot;, ncol = 2, cols = col_clusters, label.by = &quot;slide_id&quot;, show.sb = FALSE) + labs(title = &quot;Clusters&quot;) &amp; NoLegend() p2 &lt;- DimPlot(se.cor, reduction = &quot;umap.harmony&quot;, group.by = &quot;seurat_clusters&quot;, cols = col_clusters) + labs(title=&quot;UMAP&quot;) p1 - p2 + patchwork::plot_layout(widths = c(3, 2)) It looks like the clusters corresponds pretty well with the different layers in the MOB tissue. If we’d like, we can make some annotations for these clusters and correlate them to the anatomical layers. cluster_annotations &lt;- c( &quot;L09&quot;, #0 &quot;L08&quot;, #1 &quot;L02&quot;, #2 &quot;L03&quot;, #3 &quot;L05&quot;, #4 &quot;L04&quot;, #5 &quot;L06&quot;, #6 &quot;L07&quot;, #7 &quot;L01&quot;, #8 &quot;L10&quot; ) se.cor$cluster_annotation &lt;- factor(plyr::mapvalues(x = Idents(se.cor), from = 0:9, to = cluster_annotations), levels = c(paste0(&quot;L0&quot;, 1:9), &quot;L10&quot;)) col_spectral &lt;- RColorBrewer::brewer.pal(10, name = &quot;Spectral&quot;) # p1 &lt;- ST.FeaturePlot(se.cor, features = &quot;cluster_annotation&quot;, ncol = 2, cols = col_spectral) + labs(title=&quot;Clusters&quot;) &amp; NoLegend() # p2 &lt;- DimPlot(se.cor, reduction = &quot;umap.harmony&quot;, group.by = &quot;cluster_annotation&quot;, cols = col_spectral) + labs(title=&quot;UMAP&quot;) ST.FeaturePlot(se.cor, features = &quot;cluster_annotation&quot;, ncol = 2, cols = col_spectral, show.sb = F, dark.theme = T, pt.size = 2, label.by = &quot;slide_id&quot;) + labs(title=&quot;&quot;) Figure 5.5: Spatial distribution of clusters We can also plot the clusters one by one; col_spectral &lt;- RColorBrewer::brewer.pal(10, name = &quot;Spectral&quot;) ST.FeaturePlot(se.cor, features = &quot;cluster_annotation&quot;, indices = 2, cols = col_spectral, split.labels = T, pt.size = 1, ncol = 3, show.sb = F) &amp; theme(plot.title = element_blank()) "],["find-marker-genes.html", "5.7 Find marker genes", " 5.7 Find marker genes To see which genes are present in each cluster we can run the Seurat function FindAllMarkers(). gene_markers &lt;- FindAllMarkers(se.cor, only.pos = TRUE) gene_markers$cluster_annotation &lt;- factor(plyr::mapvalues(x = gene_markers$cluster, from = 0:9, to = cluster_annotations), levels = c(paste0(&quot;L0&quot;, 1:9), &quot;L10&quot;)) top3_genes &lt;- gene_markers %&gt;% dplyr::filter(p_val_adj &lt; 0.01) %&gt;% dplyr::group_by(cluster_annotation) %&gt;% dplyr::top_n(wt = avg_log2FC, n = 3) %&gt;% dplyr::arrange(cluster_annotation) top3_genes %&gt;% mutate(across(c(p_val, avg_log2FC, p_val_adj), ~ format(.x, digits = 3))) %&gt;% datatable(rownames = F, caption = paste(&quot;Top three marker genes for each cluster&quot;)) top5_genes &lt;- gene_markers %&gt;% dplyr::filter(p_val_adj &lt; 0.01) %&gt;% dplyr::group_by(cluster_annotation) %&gt;% dplyr::top_n(wt = avg_log2FC, n = 5) %&gt;% dplyr::arrange(cluster_annotation) DotPlot(se.cor, features = unique(top5_genes$gene), group.by = &quot;cluster_annotation&quot;) + scale_colour_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = &quot;RdBu&quot;) %&gt;% rev()) &amp; # coord_flip() &amp; labs(title=&quot;Cluster marker genes&quot;) &amp; theme(axis.title = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) Figure 5.6: Dot plot of top 5 marker genes per cluster. Do you see any genes that you recognize? Let’s do a few more plots :) col_scale &lt;- viridis::magma(n = 11, direction = -1) col_spectral &lt;- RColorBrewer::brewer.pal(10, name = &quot;Spectral&quot;) plot_genes &lt;- c(&quot;Nrgn&quot;, &quot;Apod&quot;) p1 &lt;- FeaturePlot(se.cor, features = plot_genes, cols = col_scale, reduction = &quot;umap.harmony&quot;) p2 &lt;- VlnPlot(se.cor, features = plot_genes, ncol = 2, group.by = &quot;cluster_annotation&quot;, cols = col_spectral) p3 &lt;- ST.FeaturePlot(se.cor, features = plot_genes, ncol = 2, grid.ncol = 2, show.sb = FALSE, cols = col_scale, label.by = &quot;slide_id&quot;) (p1 - p2)/p3 Figure 5.7: Top left: marker expression in UMAP embedding, top right: marker expression per cluster as a violin plot, bottom: marker expression on tissue sections. Here we can see how the neuronal gene Nrgn is highly expressed in clusters 1, 2, and 9, which are all present in the inner parts of the MOB tissue (granule cell layer etc), while the Apod gene is a marker of oligodendrocytes and is expressed in clusters 0 and 5, present in the outermost layers of the tissue. "],["wrap-up.html", " 6 Wrap up", " 6 Wrap up There are a lot more things one can do with the data, and what we’ve done here is just the beginning. Many new exciting tools for performing analyses of spatial omic data are being developed as we speak. What further defines these clusters that we just generated? How are some cells behaving depending on their spatial context? What will we learn if we integrate our data with scRNA-seq or other spatial omic data? Go out and explore! This analysis was last compiled on 2022-04-26. devtools::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.3 (2022-03-10) ## os macOS Monterey 12.3.1 ## system x86_64, darwin13.4.0 ## ui RStudio ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Europe/Stockholm ## date 2022-04-26 ## rstudio 2022.02.1+461 Prairie Trillium (desktop) ## pandoc 2.18 @ /Users/ludviglarsson/anaconda3/envs/R4.1/bin/ (via rmarkdown) ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────── ## package * version date (UTC) lib source ## abind 1.4-5 2016-07-21 [1] CRAN (R 4.1.3) ## akima 0.6-3.3 2022-04-19 [1] CRAN (R 4.1.3) ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 4.1.0) ## bezier 1.1.2 2018-12-14 [1] CRAN (R 4.1.3) ## bit 4.0.4 2020-08-04 [1] CRAN (R 4.1.0) ## bit64 4.0.5 2020-08-30 [1] CRAN (R 4.1.0) ## bmp 0.3 2017-09-11 [1] CRAN (R 4.1.3) ## bookdown 0.26 2022-04-15 [1] CRAN (R 4.1.3) ## boot 1.3-28 2021-05-03 [1] CRAN (R 4.1.0) ## brio 1.1.3 2021-11-30 [1] CRAN (R 4.1.1) ## bslib 0.3.1 2021-10-06 [1] CRAN (R 4.1.1) ## cachem 1.0.6 2021-08-19 [1] CRAN (R 4.1.1) ## callr 3.7.0 2021-04-20 [1] CRAN (R 4.1.0) ## class 7.3-20 2022-01-13 [1] CRAN (R 4.1.2) ## classInt 0.4-3 2020-04-07 [1] CRAN (R 4.1.0) ## cli 3.2.0 2022-02-14 [1] CRAN (R 4.1.2) ## cluster 2.1.3 2022-03-28 [1] CRAN (R 4.1.2) ## codetools 0.2-18 2020-11-04 [1] CRAN (R 4.1.0) ## colorRamps 2.3 2012-10-29 [1] CRAN (R 4.1.3) ## colorspace 2.0-3 2022-02-21 [1] CRAN (R 4.1.2) ## cowplot 1.1.1 2020-12-30 [1] CRAN (R 4.1.3) ## crayon 1.5.1 2022-03-26 [1] CRAN (R 4.1.2) ## crosstalk 1.2.0 2021-11-04 [1] CRAN (R 4.1.1) ## data.table 1.14.2 2021-09-27 [1] CRAN (R 4.1.1) ## DBI 1.1.2 2021-12-20 [1] CRAN (R 4.1.2) ## dbscan 1.1-10 2022-01-15 [1] CRAN (R 4.1.3) ## deldir 1.0-6 2021-10-23 [1] CRAN (R 4.1.1) ## desc 1.4.1 2022-03-06 [1] CRAN (R 4.1.2) ## devtools 2.4.3 2021-11-30 [1] CRAN (R 4.1.1) ## digest 0.6.29 2021-12-01 [1] CRAN (R 4.1.1) ## doParallel 1.0.17 2022-02-07 [1] CRAN (R 4.1.3) ## dplyr * 1.0.8 2022-02-08 [1] CRAN (R 4.1.2) ## DT * 0.22 2022-03-28 [1] CRAN (R 4.1.2) ## e1071 1.7-9 2021-09-16 [1] CRAN (R 4.1.1) ## ellipsis 0.3.2 2021-04-29 [1] CRAN (R 4.1.0) ## evaluate 0.15 2022-02-18 [1] CRAN (R 4.1.2) ## fansi 1.0.3 2022-03-24 [1] CRAN (R 4.1.2) ## farver 2.1.0 2021-02-28 [1] CRAN (R 4.1.0) ## fastmap 1.1.0 2021-01-25 [1] CRAN (R 4.1.0) ## fitdistrplus 1.1-8 2022-03-10 [1] CRAN (R 4.1.3) ## foreach 1.5.2 2022-02-02 [1] CRAN (R 4.1.2) ## fs 1.5.2 2021-12-08 [1] CRAN (R 4.1.3) ## future 1.24.0 2022-02-19 [1] CRAN (R 4.1.2) ## future.apply 1.8.1 2021-08-10 [1] CRAN (R 4.1.1) ## generics 0.1.2 2022-01-31 [1] CRAN (R 4.1.2) ## ggiraph 0.8.2 2022-02-22 [1] CRAN (R 4.1.2) ## ggplot2 * 3.3.5 2021-06-25 [1] CRAN (R 4.1.0) ## ggrepel 0.9.1 2021-01-15 [1] CRAN (R 4.1.3) ## ggridges 0.5.3 2021-01-08 [1] CRAN (R 4.1.3) ## globals 0.14.0 2020-11-22 [1] CRAN (R 4.1.0) ## glue 1.6.2 2022-02-24 [1] CRAN (R 4.1.2) ## goftest 1.2-3 2021-10-07 [1] CRAN (R 4.1.3) ## gridExtra 2.3 2017-09-09 [1] CRAN (R 4.1.3) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 4.1.0) ## harmony * 0.1.0 2021-06-02 [1] CRAN (R 4.1.3) ## hdf5r 1.3.5 2021-11-15 [1] CRAN (R 4.1.1) ## highr 0.9 2021-04-16 [1] CRAN (R 4.1.0) ## htmltools 0.5.2 2021-08-25 [1] CRAN (R 4.1.1) ## htmlwidgets 1.5.4 2021-09-08 [1] CRAN (R 4.1.1) ## httpuv 1.6.5 2022-01-05 [1] CRAN (R 4.1.2) ## httr 1.4.2 2020-07-20 [1] CRAN (R 4.1.0) ## ica 1.0-2 2018-05-24 [1] CRAN (R 4.1.3) ## igraph 1.3.0 2022-04-01 [1] CRAN (R 4.1.3) ## imager 0.42.13 2022-03-07 [1] CRAN (R 4.1.3) ## irlba 2.3.5 2021-12-06 [1] CRAN (R 4.1.3) ## iterators 1.0.14 2022-02-05 [1] CRAN (R 4.1.2) ## jpeg 0.1-9 2021-07-24 [1] CRAN (R 4.1.3) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.1.0) ## jsonlite 1.8.0 2022-02-22 [1] CRAN (R 4.1.2) ## KernSmooth 2.23-20 2021-05-03 [1] CRAN (R 4.1.0) ## knitr 1.38 2022-03-25 [1] CRAN (R 4.1.2) ## labeling 0.4.2 2020-10-20 [1] CRAN (R 4.1.2) ## later 1.3.0 2021-08-18 [1] CRAN (R 4.1.3) ## lattice 0.20-45 2021-09-22 [1] CRAN (R 4.1.1) ## lazyeval 0.2.2 2019-03-15 [1] CRAN (R 4.1.0) ## leiden 0.3.9 2021-07-27 [1] CRAN (R 4.1.3) ## lifecycle 1.0.1 2021-09-24 [1] CRAN (R 4.1.1) ## limma 3.50.3 2022-04-07 [1] Bioconductor ## listenv 0.8.0 2019-12-05 [1] CRAN (R 4.1.0) ## lmtest 0.9-40 2022-03-21 [1] CRAN (R 4.1.3) ## magick 2.7.3 2021-08-18 [1] CRAN (R 4.1.3) ## magrittr 2.0.3 2022-03-30 [1] CRAN (R 4.1.3) ## MASS 7.3-56 2022-03-23 [1] CRAN (R 4.1.2) ## Matrix 1.4-1 2022-03-23 [1] CRAN (R 4.1.2) ## matrixStats 0.62.0 2022-04-19 [1] CRAN (R 4.1.3) ## memoise 2.0.1 2021-11-26 [1] CRAN (R 4.1.1) ## mgcv 1.8-40 2022-03-29 [1] CRAN (R 4.1.3) ## mime 0.12 2021-09-28 [1] CRAN (R 4.1.1) ## miniUI 0.1.1.1 2018-05-18 [1] CRAN (R 4.1.0) ## Morpho 2.9 2021-09-09 [1] CRAN (R 4.1.3) ## munsell 0.5.0 2018-06-12 [1] CRAN (R 4.1.2) ## nlme 3.1-157 2022-03-25 [1] CRAN (R 4.1.2) ## NNLM 0.4.4 2022-04-20 [1] Github (linxihui/NNLM@4574bca) ## parallelly 1.31.0 2022-04-07 [1] CRAN (R 4.1.3) ## patchwork 1.1.1 2020-12-17 [1] CRAN (R 4.1.3) ## pbapply 1.5-0 2021-09-16 [1] CRAN (R 4.1.3) ## pillar 1.7.0 2022-02-01 [1] CRAN (R 4.1.2) ## pkgbuild 1.3.1 2021-12-20 [1] CRAN (R 4.1.2) ## pkgconfig 2.0.3 2019-09-22 [1] CRAN (R 4.1.0) ## pkgload 1.2.4 2021-11-30 [1] CRAN (R 4.1.1) ## plotly 4.10.0 2021-10-09 [1] CRAN (R 4.1.3) ## plyr 1.8.7 2022-03-24 [1] CRAN (R 4.1.2) ## png 0.1-7 2013-12-03 [1] CRAN (R 4.1.3) ## polyclip 1.10-0 2019-03-14 [1] CRAN (R 4.1.3) ## prettyunits 1.1.1 2020-01-24 [1] CRAN (R 4.1.0) ## processx 3.5.3 2022-03-25 [1] CRAN (R 4.1.2) ## promises 1.2.0.1 2021-02-11 [1] CRAN (R 4.1.0) ## proxy 0.4-26 2021-06-07 [1] CRAN (R 4.1.0) ## ps 1.6.0 2021-02-28 [1] CRAN (R 4.1.0) ## purrr 0.3.4 2020-04-17 [1] CRAN (R 4.1.0) ## R6 2.5.1 2021-08-19 [1] CRAN (R 4.1.1) ## RANN 2.6.1 2019-01-08 [1] CRAN (R 4.1.3) ## raster 3.5-15 2022-01-22 [1] CRAN (R 4.1.2) ## RColorBrewer 1.1-3 2022-04-03 [1] CRAN (R 4.1.3) ## Rcpp * 1.0.8.3 2022-03-17 [1] CRAN (R 4.1.2) ## RcppAnnoy 0.0.19 2021-07-30 [1] CRAN (R 4.1.3) ## readbitmap 0.1.5 2018-06-27 [1] CRAN (R 4.1.3) ## remotes 2.4.2 2021-11-30 [1] CRAN (R 4.1.1) ## reshape2 1.4.4 2020-04-09 [1] CRAN (R 4.1.0) ## reticulate 1.24 2022-01-26 [1] CRAN (R 4.1.3) ## rgl 0.108.3 2021-11-21 [1] CRAN (R 4.1.3) ## rlang 1.0.2 2022-03-04 [1] CRAN (R 4.1.2) ## rmarkdown 2.13 2022-03-10 [1] CRAN (R 4.1.2) ## ROCR 1.0-11 2020-05-02 [1] CRAN (R 4.1.3) ## rpart 4.1.16 2022-01-24 [1] CRAN (R 4.1.2) ## rprojroot 2.0.3 2022-04-02 [1] CRAN (R 4.1.3) ## rsconnect 0.8.25 2021-11-19 [1] CRAN (R 4.1.1) ## RSpectra 0.16-0 2019-12-01 [1] CRAN (R 4.1.3) ## rstudioapi 0.13 2020-11-12 [1] CRAN (R 4.1.0) ## Rtsne 0.16 2022-04-17 [1] CRAN (R 4.1.3) ## Rvcg 0.21 2022-03-18 [1] CRAN (R 4.1.3) ## s2 1.0.7 2021-09-28 [1] CRAN (R 4.1.1) ## sass 0.4.1 2022-03-23 [1] CRAN (R 4.1.2) ## scales 1.2.0 2022-04-13 [1] CRAN (R 4.1.3) ## scattermore 0.8 2022-02-14 [1] CRAN (R 4.1.3) ## sctransform 0.3.3 2022-01-13 [1] CRAN (R 4.1.3) ## sessioninfo 1.2.2 2021-12-06 [1] CRAN (R 4.1.1) ## Seurat * 4.1.0 2022-01-14 [1] CRAN (R 4.1.3) ## SeuratObject * 4.0.4 2021-11-23 [1] CRAN (R 4.1.3) ## sf 1.0-7 2022-03-07 [1] CRAN (R 4.1.2) ## shiny 1.7.1 2021-10-02 [1] CRAN (R 4.1.1) ## shinyjs 2.1.0 2021-12-23 [1] CRAN (R 4.1.3) ## sp 1.4-6 2021-11-14 [1] CRAN (R 4.1.1) ## spatstat.core 2.4-2 2022-04-01 [1] CRAN (R 4.1.3) ## spatstat.data 2.2-0 2022-04-18 [1] CRAN (R 4.1.3) ## spatstat.geom 2.4-0 2022-03-29 [1] CRAN (R 4.1.3) ## spatstat.random 2.2-0 2022-03-30 [1] CRAN (R 4.1.3) ## spatstat.sparse 2.1-1 2022-04-18 [1] CRAN (R 4.1.3) ## spatstat.utils 2.3-0 2021-12-12 [1] CRAN (R 4.1.3) ## spData 2.0.1 2021-10-14 [1] CRAN (R 4.1.1) ## spdep 1.2-4 2022-04-18 [1] CRAN (R 4.1.3) ## stringi 1.7.6 2021-11-29 [1] CRAN (R 4.1.1) ## stringr 1.4.0 2019-02-10 [1] CRAN (R 4.1.0) ## STutility * 0.1.0 2022-04-19 [1] Github (jbergenstrahle/STUtility@ec8f3f5) ## survival 3.3-1 2022-03-03 [1] CRAN (R 4.1.2) ## systemfonts 1.0.4 2022-02-11 [1] CRAN (R 4.1.2) ## tensor 1.5 2012-05-05 [1] CRAN (R 4.1.3) ## terra 1.5-21 2022-02-17 [1] CRAN (R 4.1.2) ## testthat 3.1.3 2022-03-29 [1] CRAN (R 4.1.3) ## tibble 3.1.6 2021-11-07 [1] CRAN (R 4.1.1) ## tidyr 1.2.0 2022-02-01 [1] CRAN (R 4.1.2) ## tidyselect 1.1.2 2022-02-21 [1] CRAN (R 4.1.2) ## tiff 0.1-11 2022-01-31 [1] CRAN (R 4.1.3) ## units 0.8-0 2022-02-05 [1] CRAN (R 4.1.2) ## usethis 2.1.5 2021-12-09 [1] CRAN (R 4.1.1) ## utf8 1.2.2 2021-07-24 [1] CRAN (R 4.1.0) ## uuid 1.1-0 2022-04-19 [1] CRAN (R 4.1.3) ## uwot 0.1.11 2021-12-02 [1] CRAN (R 4.1.3) ## vctrs 0.4.1 2022-04-13 [1] CRAN (R 4.1.3) ## viridis 0.6.2 2021-10-13 [1] CRAN (R 4.1.3) ## viridisLite 0.4.0 2021-04-13 [1] CRAN (R 4.1.0) ## withr 2.5.0 2022-03-03 [1] CRAN (R 4.1.2) ## wk 0.6.0 2022-01-03 [1] CRAN (R 4.1.2) ## xfun 0.30 2022-03-02 [1] CRAN (R 4.1.2) ## xtable 1.8-4 2019-04-21 [1] CRAN (R 4.1.0) ## yaml 2.3.5 2022-02-21 [1] CRAN (R 4.1.2) ## zeallot 0.1.0 2018-01-28 [1] CRAN (R 4.1.3) ## zoo 1.8-10 2022-04-15 [1] CRAN (R 4.1.3) ## ## [1] /Users/ludviglarsson/anaconda3/envs/R4.1/lib/R/library ## ## ────────────────────────────────────────────────────────────────────────────────────────────────── "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
